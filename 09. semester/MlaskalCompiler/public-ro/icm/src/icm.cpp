/*

	icm.cpp

	Mlaskal's IC machine main

	Kuba, 2006

*/

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>
#include <fstream>
#include <iterator>

#include "icm_flat_icblock.hpp"
#include "icm_machine.hpp"
#include "icexcept.hpp"

using namespace std;
using namespace mlaskal;

namespace {

	class ftor_max_reg
	{
	public:
		ftor_max_reg() : mr_(0) { }
		mlaskal::ICABSNUM get_max_reg() const { return mr_; }
		void operator()(const mlaskal::file_function &ff) { if(ff.get_used_regs()>mr_) mr_=ff.get_used_regs(); }
	private:
		mlaskal::ICABSNUM mr_;
	};

	struct ftor_prt_machine_name {
		string operator()(const icm_machines_::machine &m)
		{
			return "\t"+string(m.name_)+"\n";
		}
	};

	class pred_find_machine {
	public:
		pred_find_machine(const string &mnm) : mnm_(mnm) { }
		bool operator()(const icm_machines_::machine &m) const { return m.name_==mnm_; }
	private:
		string mnm_;
	};

	void open_files(const char *trace_file, ostream *&tf, ofstream &ofts)
	{
		if(trace_file==0)				// no trace file, so do not open
		{
			tf = 0;
			return;
		}
		else if(*trace_file==0)				// empty string - output to cerr
		{
			tf = &cerr;
			return;
		}
		ofts.exceptions(ios::badbit|ios::failbit);
		try 
		{
			ofts.open(trace_file, ios_base::out);
			tf = &ofts;
		}
		catch(...)
		{
			throw ic_except(ICET_BAD_TRACE_FILE, 0);
		}	
	}

	void close_files(ostream *&tf, ofstream &oftf)
	{
		try 
		{
			if(tf==&oftf)
				oftf.close();
		}
		catch(...)
		{
			throw ic_except(ICET_BAD_TRACE_FILE, 0);
		}	
	}

	class ftor_write_code {
	public:
		explicit ftor_write_code(ostream *tf) : tf_(tf),ip_(0) { }
		void operator()(const ic_instr *ic)
		{
			*tf_ << "\t\t<instr>\n";
			*tf_ << "\t\t\t<IP>" << ip_ << "</IP>\n";
			string opc, oper;
			ic->get_asm(opc, oper);
			*tf_ << "\t\t\t<opcode>" << opc << "</opcode>\n";
			if(oper!="")
				*tf_ << "\t\t\t<operands>" << oper << "</operands>\n";
			*tf_ << "\t\t</instr>\n";
			++ip_;
		}
	private:
		ostream *tf_;
		ICMT_ICIP ip_;
	};

}

int main(int argc, char *argv[])
{
const char *trace_file=0;
ofstream oftf;
ostream *tf;
icm_machine_trace_options to;

	to.trace_state = false;

	if(argc<3)
	{
help:
		cout << "Usage: icm <input_file> <machine> [options]\n";
		cout << "Options:\n";
		cout << "\t-Tf<trace_file>\ttrace file\n";
		cout << "\t-Ts\t\tdump full states to the trace file\n";
		cout << "Known machines:\n";
		transform(icm_machines_::machines.begin(), icm_machines_::machines.end(), ostream_iterator<string>(cout), ftor_prt_machine_name());
		return 16;
	}

	carray<icm_machines_::machine>::const_iterator m=find_if(icm_machines_::machines.begin(), icm_machines_::machines.end(),pred_find_machine(argv[2]));
	if(m==icm_machines_::machines.end())   // not found
	{
		cout << "Unknown machine name\n";
		goto help;
	}

	for(int ai=3;ai<argc;++ai)
		if(argv[ai][0]=='-' || argv[ai][0]=='/')
			switch(argv[ai][1])
			{
			case 'T':
				switch(argv[ai][2])
				{
				case 'f':
					// trace file
					trace_file = argv[ai]+3;
					break;
				case 's':
					to.trace_state = true;
					break;
				default:
					cout << "Unknown trace option " << argv[ai] << '\n';
					goto help;
				}
				break;
			default:
				cout << "Unknown option " << argv[ai] << '\n';
				goto help;
			}
		else
		{
			cout << "Unexpected parameter " << argv[ai] << '\n';
			goto help;
		}

	try
	{
		icm_flat_icblock inic(argv[1]);

		open_files(trace_file, tf, oftf);

		// compute required number of registers
		ftor_max_reg fmv;
		fmv = for_each(inic.get_fncs().begin(), inic.get_fncs().end(), fmv);

		// construct the machine
		icm_machine *the_machine = machine_factory::create_machine(*m, fmv.get_max_reg(), &inic, tf, to);

		// start the trace
		if(tf)
		{
			*tf << "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n";
			*tf << "<!-- Generated by ICM at " << __DATE__ << ", " << __TIME__ << " -->\n";
			*tf << "<icm_trace>\n";
			*tf << "\t<trace_info>\n";
			*tf << "\t\t<input_file>" << argv[1] << "</input_file>\n";
			*tf << "\t\t<machine_name>" << the_machine->get_name() << "</machine_name>\n";
			*tf << "\t</trace_info>\n";
			*tf << "\t<code>\n";
			for_each(inic.get_icblock().begin(), inic.get_icblock().end(), ftor_write_code(tf));
			*tf << "\t</code>\n";
			*tf << "\t<ticks>\n";
		}

		// do simulation
		the_machine->simulate();

		// end the trace
		if(tf)
		{
			*tf << "\t</ticks>\n";
			the_machine->write_stats();
			*tf << "</icm_trace>\n";
		}

		close_files(tf, oftf);
	}
	catch(const ic_except &iex)
	{
		cout << "ERROR: " << iex.get_msg();
		if(iex.has_ip())
			cout << " on IP=" << iex.get_ip();
		cout << '\n';
	}

	return 0;
}
